(* Code generated by go generate; DO NOT EDIT. *)

decl = dataDecl | typeDecl | varDecl | infixDecl ; (* func decl *)

dataDecl = "data" IDENT (typeparams1)? "=" "{" constructor ("," constructor)* ","? "}" ;
typeparams1 = "(" IDENT ("," IDENT)* ","? ")" ; (* func dataDecl *)

typeDecl = "type" IDENT (typeparams1)? "=" type ; (* func typeDecl *)

constructor = UPPER_IDENT typeparams ;
typeparams = "(" (type ("," type)*)? ")" ; (* func constructor *)

varDecl = "def" IDENT "=" expr | "def" IDENT ":" type | "def" IDENT ":" type "=" expr ; (* func varDecl *)

infixDecl = ("infix" | "infixl" | "infixr") INTEGER OPERATOR ; (* func infixDecl *)

expr = let | with | assert ; (* func expr *)

let = "let" pattern "=" assert ; (* func let *)

with = "with" withBind "<-" assert | "with" assert ;
withBind = pattern ("," pattern)* "," ; (* func with *)

atom = var | literal | paren | tuple | codata | PRIM "(" IDENT ("," expr)* ","? ")" ;
var = IDENT ;
literal = INTEGER | STRING ;
paren = "(" ")" | "(" expr ")" ;
tuple = "[" "]" | "[" expr ("," expr)* ","? "]" ;
codata = "{" clause ("," clause)* ","? "}" ; (* func atom *)

assert = binary (":" type)* ; (* func assert *)

binary = method (operator method)* ; (* func binary *)

method = atom (accessTail | callTail)* ; (* func method *)

accessTail = "." IDENT callTail? ; (* func accessTail *)

callTail = "(" ")" | "(" expr ("," expr)* ","? ")" ; (* func callTail *)

codata = "{" clause ("," clause)* ","? "}" ; (* func codata *)

clause = clauseHead "->" clauseBody | clauseBody ;
clauseHead = "(" ")" | "(" pattern ("," pattern)* ","? ")" | pattern ;
clauseBody = expr (";" expr)* ";"? ; (* func clause *)

pattern = methodPat ; (* func pattern *)

methodPat = atomPat (accessPatTail | callPatTail)* ; (* func methodPat *)

accessPatTail = "." IDENT callPatTail? ; (* func accessPatTail *)

callPatTail = "(" ")" | "(" pattern ("," pattern)* ","? ")" ; (* func callPatTail *)

atomPat = IDENT | INTEGER | STRING | "(" pattern ")" | tuplePat ;
tuplePat = "[" "]" | "[" pattern ("," pattern)* ","? "]" ; (* func atomPat *)

type = binopType ; (* func typ *)

binopType = callType (operator callType)* ; (* func binopType *)

callType = (PRIM "(" IDENT ("," type)* ","? ")" | atomType) ("(" ")" | "(" type ("," type)* ","? ")")* ; (* func callType *)

atomType = IDENT | "{" fieldType ("," fieldType)* ","? "}" | "(" type  ")" | tupleType ;
tupleType = "[" "]" | "[" type ("," type)* ","? "]"; (* func atomType *)

fieldType = IDENT ":" type ; (* func fieldType *)

peek returns the current token in the token stream without consuming it. (* func peek *)

advance moves the parser to the next token in the token stream.
It returns the current token before advancing. (* func advance *)

previous returns the previous token in the token stream. (* func previous *)

IsAtEnd checks if the parser has reached the end of the input. (* func IsAtEnd *)

match checks if the current token in the input stream has the specified kind.
It returns true if the current token matches the specified kind, false otherwise. (* func match *)

