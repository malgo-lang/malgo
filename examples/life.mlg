let extern print_char : Char -> {} = "print_char" in
let extern newline : () -> {} = "newline" in
let extern gen_seed: () -> {} = "gen_seed" in
let extern rand_bool : () -> Bool = "rand_bool" in
let extern sleep : Int -> {} = "malgo_sleep" in
let fun pulsar(cells: [Bool]) =
  cells.(11 * 50 + 23) <- true;
  cells.(11 * 50 + 23) <- true;
  cells.(12 * 50 + 23) <- true;
  cells.(13 * 50 + 23) <- true;

  cells.(12 * 50 + 25) <- true;

  cells.(11 * 50 + 27) <- true;
  cells.(12 * 50 + 27) <- true;
  cells.(13 * 50 + 27) <- true in

let val x_width : Int = 50 in
let val y_width : Int = 20 in
let val cells : [Bool] = array(false, x_width * y_width) in

let fun view(cells: [Bool], x: Int, y: Int): Bool =
  if (x >= x_width) || (y >= y_width) || (x < 0) || (y < 0)
  then false
  else cells.(y * x_width + x) in
let fun set(cells: [Bool], x: Int, y: Int, s: Bool): {} =
  cells.(y * x_width + x) <- s in

let fun init_cells(cells: [Bool], i: Int): {} =
  if i >= x_width * y_width
  then {}
  else cells.(i) <- rand_bool(); init_cells(cells, i + 1) in

let fun to_char(s: Bool): Char =
  if s
  then '#'
  else '_' in

let fun print_cells(cells: [Bool]): {} =
  let fun go_y(y: Int): {} =
    let fun go_x(x: Int): {} =
      if x >= x_width
      then {}
      else (print_char(to_char(view(cells, x, y))); go_x(x + 1)) in
    if y >= y_width
    then {}
    else (go_x(0); newline(); go_y(y + 1)) in
  go_y(0) in

let fun to_int(b: Bool): Int = if b then 1 else 0 in

let fun next_state(cells: [Bool], x: Int, y: Int): Bool =
  let val living: [Int] = array(0, 1) in
  living.(0) <- to_int(view(cells, x-1, y+1)) + to_int(view(cells, x, y+1)) + to_int(view(cells, x+1, y+1));
  living.(0) <- to_int(view(cells, x-1, y)) + to_int(view(cells, x+1, y)) + living.(0);
  living.(0) <- to_int(view(cells, x-1, y-1)) + to_int(view(cells, x, y-1)) + to_int(view(cells, x+1, y-1)) + living.(0);
  if view(cells, x, y)
  then (living.(0) == 2) || (living.(0) == 3)
  else (living.(0) == 3) in

let fun copy_cells(cells: [Bool]): [Bool] =
  let val copy = array(false, x_width * y_width) in
  let fun go(i: Int): {} =
    if i >= x_width * y_width
      then {}
      else copy.(i) <- cells.(i); go(i + 1) in
  go(0); copy in
  
let fun update_cells(cells: [Bool]): {} =
  let val copy: [Bool] = copy_cells(cells) in
  let fun go_y(y: Int): {} =
      let fun go_x(x: Int): {} =
        if x >= x_width
        then {}
        else set(cells, x, y, next_state(copy, x, y)); go_x(x + 1) in
      if y >= y_width
      then {}
      else go_x(0); go_y(y + 1) in
  go_y(0) in

gen_seed();
pulsar(cells);

let fun loop(n:Int): {} =
  if n > 0
  then (print_cells(cells);
  	  update_cells(cells);
        newline();
        -- sleep(1);
        loop(n - 1))
  else {} in
loop(10)