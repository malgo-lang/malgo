# Malgo Compiler Development Guide

## Architecture Overview

Malgo is a statically-typed functional language compiler written in Haskell. The compiler follows a multi-stage pipeline with intermediate representations (IRs):

**Compilation Pipeline**: `Source (.mlg) → Parse → Rename → ToFun → ToCore → Flat → Join → Eval`

### Key Components

- **Pass System**: All phases implement `Pass` typeclass in `src/Malgo/Pass.hs` with uniform error handling via `CompileError`
- **Phase-Indexed AST**: `src/Malgo/Syntax.hs` uses type-level phases (`Malgo Parse`, `Malgo Rename`) to track compilation stages
- **Module System**: Tracks dependencies in `.malgo-works/` with interface files (`.mlgi`) for separate compilation
- **Driver**: `src/Malgo/Driver.hs` orchestrates the pipeline with `withDump` for debugging intermediate representations

## Development Workflow

```bash
# Essential commands (never use plain cabal/ghc directly)
mise run build    # Format + compile (uses ormolu, hpack)
mise run test     # Run full test suite
mise run test --match="Parser"  # Run specific tests

# Reset golden files when test outputs change
mise run reset

# Running the compiler
malgo eval examples/malgo/Hello.mlg
malgo eval --debug-mode --no-opt examples/malgo/Hello.mlg  # See all IR stages
```

## Critical Conventions

### String Output (High Priority - Different from Standard Haskell)

1. **`pShow`** (`Text.Pretty.Simple`) - Debug/logging only, for any `Show` instance
2. **`pretty`** (`Prettyprinter`) - User-facing output, for types with `Pretty` instances
3. **`sShow`** (`Malgo.SExpr`) - ASTs and IRs only, produces S-expression format

**Never use regular `show` for compiler output** - always use one of the above three functions.

### Pass Development Pattern

All compiler phases follow this structure:
```haskell
data SomePass = SomePass

instance Pass SomePass where
  type Input SomePass = InputType
  type Output SomePass = OutputType
  type ErrorType SomePass = SomeError
  type Effects SomePass es = (State Uniq :> es, Reader ModuleName :> es)
  runPassImpl _ = actualImplementation
```

Use `wrapCompileError` when bridging different error types to maintain the uniform `CompileError` wrapper.

### Testing Patterns

- **Golden Testing**: Use `golden "description" $ do ...` from `Malgo.TestUtils`
- **Pass Testing**: `runPass SomePass input` pattern for individual compiler phases
- **Test Files**: `test/testcases/malgo/*.mlg` with expected outputs in `.golden/` directory
- **Reset Golden Files**: `mise run reset` when test outputs legitimately change

### Error Handling & Debugging

- All passes use `CompileError` wrapper with call stacks
- Use `wrapCompileError` when bridging different error types
- Debug with `--debug-mode` to see full pipeline dumps via `withDump`
- Check `.malgo-works/` for cached module interfaces during debugging

## File Organization

### Core Compiler (src/Malgo/)

- `Driver.hs` - Pipeline orchestration, `withDump` for IR debugging
- `Syntax.hs` - Phase-indexed AST definitions (501 lines, critical)
- `Pass.hs` - Pass abstraction and unified error handling
- `Monad.hs` - Compiler monad stack with effects

## Naming Conventions

- Use descriptive names for all identifiers (avoid single letters except in mathematical contexts)
- When no meaningful name exists, use lowercase type name as variable name
- Consider renaming legacy single-letter variables to improve readability in large functions

## Malgo Language Specifics

### Module Import Pattern

```malgo
module {..} = import "../../runtime/malgo/Builtin.mlg"
module {..} = import "../../runtime/malgo/Prelude.mlg"
```

### Function Definition Syntax

```malgo
def functionName : Type -> Type
def functionName = { pattern -> body }
```

### Key Language Features

- ML-style syntax with curly braces `{ }`
- Pattern matching with multiple clauses separated by commas
- Explicit type annotations (no inference)
- Infix operators with precedence declarations (`infix`, `infixl`, `infixr`)
- Unboxed primitives (`Int32#`, `String#`) vs boxed types (`Int32`, `String`)
- Foreign function interface for runtime primitives

## Build System & Dependencies

### Critical Build Rules

- **Never edit `malgo.cabal` directly** - it's generated by hpack from `package.yaml`
- **Always use `mise run build`** - includes formatting with ormolu and hpack regeneration
- **Use mise tasks exclusively** - defined in `mise.toml`, avoid direct cabal/ghc commands
- **Effectful Framework**: All compiler code uses effectful effects system, not mtl

### Runtime Dependencies

- `runtime/malgo/Builtin.mlg` - Core primitives (`Int32#`, foreign imports, panic/undefined)
- `runtime/malgo/Prelude.mlg` - Standard library (List, Maybe, basic functions)
- Both must be compiled before user programs can run
