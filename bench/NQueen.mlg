module NQueen = {
  module {..} = import Builtin;
  module {..} = import Prelude;

  and =
    { True True -> True
    | _ _ -> False
    };

  andalso =
    { False _ -> False
    | True x -> x ()
    };

  or =
    { False False -> False
    | _ _ -> True
    };

  orelse =
    { True _ -> True
    | False x -> x ()
    };

  data Maybe a = Nothing | Just a;

  infixl 6 (+);
  (+) = { x y -> addInt32 x y };

  infixl 6 (-);
  (-) = { x y -> subInt32 x y };

  infixl 6 (+!);
  (+!) = { x y -> addInt64 x y };

  infixl 6 (-!);
  (-!) = { x y -> subInt64 x y };

  ------------
  -- Vector --
  ------------
  foreign import malgo_unsafe_cast : a -> b;

  foreign import malgo_new_vector : Int64# -> Ptr# Char# -> Ptr# (Ptr# Char#);

  foreign import malgo_read_vector : Int64# -> Ptr# (Ptr# Char#) -> Ptr# Char#;

  foreign import malgo_write_vector : Int64# -> Ptr# (Ptr# Char#) -> Ptr# Char# -> ();

  data Vector a = Vector Int64 (Ptr# a);

  newVector : Int64 -> a -> Vector a;
  newVector = { (Int64# length) init ->
    Vector (Int64# length) (malgo_unsafe_cast (malgo_new_vector length (malgo_unsafe_cast init)))
  };

  readVector : Int64 -> Vector a -> Maybe a;
  readVector = { (Int64# index) (Vector (Int64# length) ptr) ->
    if (isTrue# (geInt64# index length))
    { Nothing }
    { Just (malgo_unsafe_cast (malgo_read_vector index (malgo_unsafe_cast ptr))) }
  };

  readVector' = { index vec -> readVector index vec |> { Nothing -> panic "error" | Just x -> x } };

  writeVector : Int64 -> Vector a -> a -> ();
  writeVector = { (Int64# index) (Vector (Int64# length) ptr) val ->
    if (isTrue# (geInt64# index length))
    { panic "invalid input" }
    { malgo_write_vector index (malgo_unsafe_cast ptr) (malgo_unsafe_cast val) }
  };

  -------------
  -- n-queen --
  -------------

  n = 8L;

  row = newVector n 0L;

  col = newVector n 0L;

  diag1 = newVector (n +! n -! 1L) 0L;

  diag2 = newVector (n +! n -! 1L) 0L;

  for = { start end k ->
    if (geInt64 start end)
      { () }
      { k start; for (start +! 1L) end k }
  };

  printBoard = {
    for 0L n { i ->
      for 0L n { j ->
        let cell = readVector i col |> { Nothing -> panic "error" | Just x -> x };
        putStr (if (eqInt64 cell j) { " O" } { " ." })
      };
      putStrLn ""
    };
    putStrLn ""
  };

  try = { c ->
    if (eqInt64 c n)
    { printBoard () }
    { for 0L n { r -> 
        if (andalso (eqInt64 (readVector' r row) 0L)
                {andalso (eqInt64 (readVector' (r +! c) diag1) 0L)
                     {eqInt64 (readVector' (r +! (n -! 1L) -! c) diag2) 0L}})
        { 
          writeVector r row 1L;
          writeVector (r +! c) diag1 1L;
          writeVector (r +! (n -! 1L) -! c) diag2 1L;
          writeVector c col r;
          try (c +! 1L);
          writeVector r row 0L;
          writeVector (r +! c) diag1 0L;
          writeVector (r +! (n -! 1L) -! c) diag2 0L
        }
        { () }
      }
    }
  };

  main = {
    printBoard ();
    try 0L
  };
}
