(in-package :cl-user)
(defpackage malgo.lexer
  (:use :cl :cl-lex))
(in-package :malgo.lexer)

(define-string-lexer ml-lexer-without-comment
  ("\\("    (return (values 'lparen $@)))
  ("\\)"    (return (values 'rparen $@)))
  ("true"   (return (values 'bool :true)))
  ("false"  (return (values 'bool :false)))
  ("[0-9]+" (return (values 'int (read-from-string $@))))
  ("[0-9]+(\\.[0-9]*)?([eE][+-]?[0-9]+)?" (return (values 'float (read-from-string $@))))
  ("-"      (return (values 'minus $@)))
  ("\\+"    (return (values 'plus  $@)))
  ("-\\."   (return (values 'minus-dot $@)))
  ("\\+\\." (return (values 'plus-dot  $@)))
  ("\\*\\." (return (values 'ast_dot   $@)))
  ("/\\."   (return (values 'slash_dot $@)))
  ("="      (return (values 'equal     $@)))
  ("<>"     (return (values 'less-greater  $@)))
  ("<="     (return (values 'less-equal    $@)))
  (">="     (return (values 'greater-equal $@)))
  ("<"      (return (values 'less    $@)))
  (">"      (return (values 'greater $@)))
  ("if"     (return (values 'if      $@)))
  ("then"   (return (values 'then    $@)))
  ("else"   (return (values 'else    $@)))
  ("let"    (return (values 'let     $@)))
  ("in"     (return (values 'in      $@)))
  (","      (return (values 'comma   $@)))
  ;; ("_"      (return (values 'ident   (malgo.id:gentmp malgo.type:unit))))
  ("Array\\.create" (return (values 'array-create $@)))
  ("\\."    (return (values 'dot $@)))
  ("<-"     (return (values 'less-minus $@)))
  (";"      (return (values 'semicolon  $@)))
  ("[a-z]([0-9]|[a-z]|[A-Z]|_)*" (return (values 'ident $@)))
  )

(let ((depth 0))

  (defun remove-comments (src &optional result)
    (let ((src (if (listp src) src (concatenate 'list src))))
      (cond ((equal #\( (first src))
             (if (openp (second src))
                 (remove-comments (cddr src) result)
                 (remove-comments (cdr src) (build-source #\( result))))
            ((equal #\* (first src))
             (if (closep (second src))
                 (remove-comments (cddr src) result)
                 (remove-comments (cdr src) (build-source #\* result))))
            ((null src) (concatenate 'string (nreverse result)))
            (t (remove-comments (rest src) (build-source (first src) result))))))

  (defun openp (next)
    (cond ((equal #\* next) (progn (incf depth) t))
          (t nil)))
  (defun closep (next)
    (cond ((equal #\) next) (progn (decf depth) t))
          (t nil)))

  (defun build-source (char result)
    (if (= depth 0)
        (cons char result)
        result)))

(defun ml-lexer (src)
  (ml-lexer-without-comment (remove-comments src)))
