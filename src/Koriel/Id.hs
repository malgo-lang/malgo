{-# LANGUAGE CPP #-}

module Koriel.Id
  ( IdSort (..),
    ModuleName (..),
    Id (..),
    idToText,
    newInternalId,
    newExternalId,
    noName,
    idIsExternal,
    newIdOnName,
    cloneId,
    newNoNameId,
    newTemporalId,
    newNativeId,
    idIsNative,
  )
where

import Codec.Serialise
import Data.Aeson
import Data.Binary (Binary)
import Data.Data (Data)
import Data.Store (Store)
import GHC.Exts
import Koriel.Lens
import Koriel.MonadUniq
import Koriel.Prelude hiding (toList)
import Koriel.Pretty as P
import Numeric (showHex)

newtype ModuleName = ModuleName {raw :: Text}
  deriving stock (Eq, Show, Ord, Generic, Data, Typeable)

instance Binary ModuleName

instance ToJSON ModuleName

instance FromJSON ModuleName

instance Hashable ModuleName

instance Serialise ModuleName

instance Store ModuleName

instance Pretty ModuleName where
  pPrint (ModuleName modName) = pPrint modName

-- | Identifier sort.
data IdSort
  = -- | Identifiers that can be referenced by other `External` modules.
    -- They are printed as `ModuleName.idName`.
    External ModuleName
  | -- | Identifiers closed in the module. They are not visible outside (so `Internal`) the module.
    -- They are printed as `idName_deadbeaf`.
    Internal
  | -- | Temporary variable identifiers generated by the compiler.
    -- For dev experience, these are printed with a prefix `$`.
    Temporal
  | -- | Native identifiers, e.g. `main` that is the entry point function name.
    --   These are only generated by the compiler.
    --   These are `Native`, so they are printed raw. No prefix and no postfix.
    Native
  deriving stock (Eq, Show, Ord, Generic, Data, Typeable)

instance Binary IdSort

instance ToJSON IdSort

instance FromJSON IdSort

instance Hashable IdSort

instance Serialise IdSort

instance Store IdSort

instance Pretty IdSort where
  pPrint (External modName) = "External" <+> pPrint modName
  pPrint Internal = "Internal"
  pPrint Temporal = "Temporal"
  pPrint Native = "Native"

data Id a = Id
  { name :: Text,
    uniq :: Int,
    meta :: a,
    sort :: IdSort
  }
  deriving stock (Show, Eq, Ord, Functor, Foldable, Traversable, Generic, Data, Typeable)

instance Hashable a => Hashable (Id a)

instance Binary a => Binary (Id a)

instance ToJSON a => ToJSON (Id a)

instance ToJSON a => ToJSONKey (Id a)

instance FromJSON a => FromJSON (Id a)

instance FromJSON a => FromJSONKey (Id a)

instance Serialise a => Serialise (Id a)

instance Store a => Store (Id a)

noName :: Text
noName = "noName"

idToText :: Id a -> Text
idToText Id {name, sort = External (ModuleName modName)} = modName <> "." <> name
idToText Id {name, uniq, sort = Internal} = name <> "_" <> toText (showHex uniq "")
idToText Id {name, uniq, sort = Temporal} = "$" <> name <> "_" <> toText (showHex uniq "")
idToText Id {name, sort = Native} = name

pPrintMeta :: (t -> Doc) -> t -> Doc

#ifdef DEBUG
pPrintMeta ppr x = braces (ppr x)
#else
pPrintMeta _ _ = mempty
#endif

instance Pretty a => Pretty (Id a) where
  pPrint id@(Id _ _ m _) = pprIdName id <> pPrintMeta pPrint m
    where
      pprIdName :: Id a -> Doc
      pprIdName = text . toString . idToText

newNoNameId :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => a -> IdSort -> f (Id a)
newNoNameId m s = Id noName <$> getUniq <*> pure m <*> pure s

newTemporalId :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => Text -> a -> f (Id a)
newTemporalId n m = Id n <$> getUniq <*> pure m <*> pure Temporal

newInternalId :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => Text -> a -> f (Id a)
newInternalId n m = Id n <$> getUniq <*> pure m <*> pure Internal

newExternalId :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => Text -> a -> ModuleName -> f (Id a)
newExternalId n m modName = Id n <$> getUniq <*> pure m <*> pure (External modName)

newNativeId :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => Text -> a -> f (Id a)
newNativeId n m = Id n <$> getUniq <*> pure m <*> pure Native

newIdOnName :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => a -> Id b -> f (Id a)
newIdOnName meta Id {name, sort} = Id name <$> getUniq <*> pure meta <*> pure sort

cloneId :: (MonadIO m, HasUniqSupply env UniqSupply, MonadReader env m) => Id a -> m (Id a)
cloneId Id {..} = do
  uniq <- getUniq
  pure Id {name, uniq, meta, sort}

idIsExternal :: Id a -> Bool
idIsExternal Id {sort = External _} = True
idIsExternal _ = False

idIsNative :: Id a -> Bool
idIsNative Id {sort = Native} = True
idIsNative _ = False
