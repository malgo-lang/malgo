{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

module Koriel.Id
  ( IdSort (..),
    ModuleName (..),
    Id (..),
    idToText,
    newInternalId,
    newExternalId,
    idIsExternal,
    newTemporalId,
    newNativeId,
    idIsNative,
    HasModuleName,
  )
where

import Data.Aeson (FromJSON, ToJSON)
import Data.Data (Data)
import Data.Hashable (Hashable (..))
import Data.Store ()
import Data.Store.TH
import Effectful (Eff, (:>))
import Effectful.Reader.Static (Reader, ask)
import Effectful.State.Static.Local (State)
import GHC.Records
import Koriel.MonadUniq
import Koriel.Prelude hiding (toList)
import Koriel.Pretty as P

newtype ModuleName = ModuleName {raw :: Text}
  deriving stock (Eq, Show, Ord, Generic, Data, Typeable)
  deriving newtype (Hashable, Pretty, ToJSON, FromJSON)

makeStore ''ModuleName

type HasModuleName r = HasField "moduleName" r ModuleName

instance HasField "moduleName" ModuleName ModuleName where
  getField = identity

-- | Identifier sort.
data IdSort
  = -- | Identifiers that can be referenced by other `External` modules.
    -- They are printed as `ModuleName.idName`.
    External
  | -- | Identifiers closed in the module. They are not visible outside (so `Internal`) the module.
    -- They are printed as `idName_deadbeaf`.
    Internal
  | -- | Temporary variable identifiers generated by the compiler.
    -- For dev experience, these are printed with a prefix `$`.
    Temporal
  | -- | Native identifiers, e.g. `main` that is the entry point function name.
    --   These are only generated by the compiler.
    --   These are `Native`, so they are printed raw. No prefix and no postfix.
    Native
  deriving stock (Eq, Show, Ord, Generic, Data, Typeable)
  deriving anyclass (Hashable, ToJSON, FromJSON)
  deriving (Pretty) via PrettyShow IdSort

makeStore ''IdSort

-- TODO: Add uniq :: Int field
data Id a = Id
  { name :: Text,
    meta :: a,
    moduleName :: ModuleName,
    uniq :: Int, -- Unique number for each Id. If sort == Native or External, uniq is always -1.
    sort :: IdSort
  }
  deriving stock (Show, Ord, Functor, Foldable, Traversable, Generic, Data, Typeable)
  deriving anyclass (ToJSON, FromJSON)

instance Eq (Id a) where
  -- Don't compare meta
  (==) Id {name = name1, moduleName = moduleName1, uniq = uniq1, sort = sort1} Id {name = name2, moduleName = moduleName2, uniq = uniq2, sort = sort2} =
    name1 == name2 && moduleName1 == moduleName2 && uniq1 == uniq2 && sort1 == sort2
  {-# INLINE (==) #-}

instance Hashable (Id a) where
  hash Id {name, moduleName, uniq, sort} = hash name `hashWithSalt` hash moduleName `hashWithSalt` hash uniq `hashWithSalt` hash sort
  {-# INLINE hash #-}
  hashWithSalt salt Id {name, moduleName, uniq, sort} = salt `hashWithSalt` hash name `hashWithSalt` hash moduleName `hashWithSalt` hash uniq `hashWithSalt` hash sort
  {-# INLINE hashWithSalt #-}

instance Pretty (Id a) where
  pretty Id {name, moduleName, sort = External} = "@" <> brackets (pretty moduleName <+> pretty name)
  pretty Id {name, moduleName, uniq, sort = Internal} = "#" <> brackets (pretty moduleName <+> pretty name <+> pretty uniq)
  pretty Id {name, moduleName, uniq, sort = Temporal} = "$" <> brackets (pretty moduleName <+> pretty name <+> pretty uniq)
  pretty Id {name, sort = Native} = "%" <> pretty name

makeStore ''Id

idToText :: Id a -> Text
idToText Id {name, moduleName, sort = External} = moduleName.raw <> "." <> name
idToText Id {name, moduleName, uniq, sort = Internal} = moduleName.raw <> ".#" <> name <> "_" <> convertString (show uniq)
idToText Id {name, moduleName, uniq, sort = Temporal} = moduleName.raw <> ".$" <> name <> "_" <> convertString (show uniq)
idToText Id {name, sort = Native} = name

newTemporalId :: (State Uniq :> es, Reader ModuleName :> es) => Text -> a -> Eff es (Id a)
newTemporalId name meta = do
  uniq <- getUniq
  moduleName <- ask @ModuleName
  let sort = Temporal
  pure Id {..}

newInternalId :: (State Uniq :> es, Reader ModuleName :> es) => Text -> a -> Eff es (Id a)
newInternalId name meta = do
  uniq <- getUniq
  moduleName <- ask @ModuleName
  let sort = Internal
  pure Id {..}

newExternalId :: (Reader ModuleName :> es) => Text -> a -> Eff es (Id a)
newExternalId name meta = do
  moduleName <- ask @ModuleName
  let uniq = -1
  let sort = External
  pure Id {..}

newNativeId :: (Reader ModuleName :> es) => Text -> a -> Eff es (Id a)
newNativeId name meta = do
  moduleName <- ask @ModuleName
  let uniq = -1
  let sort = Native
  pure Id {..}

idIsExternal :: Id a -> Bool
idIsExternal Id {sort = External} = True
idIsExternal _ = False

idIsNative :: Id a -> Bool
idIsNative Id {sort = Native} = True
idIsNative _ = False
