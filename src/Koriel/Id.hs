{-# LANGUAGE CPP #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE OverloadedStrings #-}

module Koriel.Id
  ( IdSort (..),
    ModuleName (..),
    HasModuleName (..),
    Id (..),
    idToText,
    newInternalId,
    newExternalId,
    idIsExternal,
    newTemporalId,
    newNativeId,
    idIsNative,
  )
where

import Control.Lens (Lens', view)
import Data.Aeson (FromJSON, ToJSON)
import Data.Binary (Binary)
import Data.Data (Data)
import Data.String.Conversions (convertString)
import Koriel.MonadUniq
import Koriel.Prelude hiding (toList)
import Koriel.Pretty as P
import Numeric (showHex)

newtype ModuleName = ModuleName {raw :: Text}
  deriving stock (Eq, Show, Ord, Generic, Data, Typeable)
  deriving newtype (Hashable, Binary, Pretty, ToJSON, FromJSON)

class HasModuleName s a | s -> a where
  moduleName :: Lens' s a

instance HasModuleName ModuleName ModuleName where
  moduleName = identity

-- | Identifier sort.
data IdSort
  = -- | Identifiers that can be referenced by other `External` modules.
    -- They are printed as `ModuleName.idName`.
    External
  | -- | Identifiers closed in the module. They are not visible outside (so `Internal`) the module.
    -- They are printed as `idName_deadbeaf`.
    Internal
  | -- | Temporary variable identifiers generated by the compiler.
    -- For dev experience, these are printed with a prefix `$`.
    Temporal
  | -- | Native identifiers, e.g. `main` that is the entry point function name.
    --   These are only generated by the compiler.
    --   These are `Native`, so they are printed raw. No prefix and no postfix.
    Native
  deriving stock (Eq, Show, Ord, Generic, Data, Typeable)
  deriving anyclass (Hashable, Binary, ToJSON, FromJSON)
  deriving (Pretty) via PrettyShow IdSort

data Id a = Id
  { name :: Text,
    meta :: a,
    moduleName :: ModuleName,
    sort :: IdSort
  }
  deriving stock (Show, Eq, Ord, Functor, Foldable, Traversable, Generic, Data, Typeable)
  deriving anyclass (Hashable, Binary, ToJSON, FromJSON)

instance Pretty (Id a) where
  pPrint Id {name, moduleName, sort = External} = pPrint moduleName <> "." <> pPrint name
  pPrint Id {name, sort = Internal} = pPrint name
  pPrint Id {name, sort = Temporal} = "$" <> pPrint name
  pPrint Id {name, sort = Native} = pPrint name

idToText :: Id a -> Text
idToText id@Id {moduleName, sort = Internal} = moduleName.raw <> "." <> convertString (render $ pPrint id)
idToText id@Id {moduleName, sort = Temporal} = moduleName.raw <> "." <> convertString (render $ pPrint id)
idToText id = convertString $ render $ pPrint id

newTemporalId :: (MonadReader s m, MonadIO m, HasModuleName s ModuleName, HasUniqSupply s) => Text -> a -> m (Id a)
newTemporalId name meta = do
  uniq <- getUniq
  name <- pure $ name <> "_" <> convertString (showHex uniq "")
  moduleName <- view moduleName
  let sort = Temporal
  pure Id {..}

newInternalId :: (MonadIO f, HasModuleName env ModuleName, MonadReader env f, HasUniqSupply env) => Text -> a -> f (Id a)
newInternalId name meta = do
  uniq <- getUniq
  name <- pure $ name <> "_" <> convertString (showHex uniq "")
  moduleName <- view moduleName
  let sort = Internal
  pure Id {..}

newExternalId :: (MonadReader env f, HasModuleName env ModuleName) => Text -> a -> f (Id a)
newExternalId name meta = do
  moduleName <- view moduleName
  let sort = External
  pure Id {..}

newNativeId :: (MonadReader env f, HasModuleName env ModuleName) => Text -> a -> f (Id a)
newNativeId name meta = do
  moduleName <- view moduleName
  let sort = Native
  pure Id {..}

idIsExternal :: Id a -> Bool
idIsExternal Id {sort = External} = True
idIsExternal _ = False

idIsNative :: Id a -> Bool
idIsNative Id {sort = Native} = True
idIsNative _ = False
