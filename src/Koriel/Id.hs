{-# LANGUAGE CPP #-}

module Koriel.Id
  ( IdSort (..),
    ModuleName (..),
    Id (..),
    idName,
    idUniq,
    idMeta,
    idSort,
    idToText,
    newInternalId,
    newExternalId,
    noName,
    idIsExternal,
    newIdOnName,
    cloneId,
    newNoNameId,
    newTemporalId,
    newNativeId,
    idIsNative,
  )
where

import Control.Lens (Lens, Lens', lens)
import Data.Aeson
import Data.Binary (Binary)
import Data.Data (Data)
import Data.Functor.Classes
import GHC.Exts
import Koriel.Lens
import Koriel.MonadUniq
import Koriel.Prelude hiding (toList)
import Koriel.Pretty as P
import Numeric (showHex)
import Text.Show (showString, showsPrec)

newtype ModuleName = ModuleName {raw :: Text}
  deriving stock (Eq, Show, Ord, Generic, Data, Typeable)

instance Binary ModuleName

instance ToJSON ModuleName

instance FromJSON ModuleName

instance Hashable ModuleName

instance Pretty ModuleName where
  pPrint (ModuleName modName) = pPrint modName

-- | Identifier sort.
data IdSort
  = -- | Identifiers that can be referenced by other `External` modules.
    -- They are printed as `ModuleName.idName`.
    External ModuleName
  | -- | Identifiers closed in the module. They are not visible outside (so `Internal`) the module.
    -- They are printed as `idName_deadbeaf`.
    Internal
  | -- | Temporary variable identifiers generated by the compiler.
    -- For dev experience, these are printed with a prefix `$`.
    Temporal
  | -- | Native identifiers, e.g. `main` that is the entry point function name.
    --   These are only generated by the compiler.
    --   These are `Native`, so they are printed raw. No prefix and no postfix.
    Native
  deriving stock (Eq, Show, Ord, Generic, Data, Typeable)

instance Binary IdSort

instance ToJSON IdSort

instance FromJSON IdSort

instance Hashable IdSort

instance Pretty IdSort where
  pPrint (External modName) = "External" <+> pPrint modName
  pPrint Internal = "Internal"
  pPrint Temporal = "Temporal"
  pPrint Native = "Native"

data Id a = Id
  { _idName :: Text,
    _idUniq :: Int,
    _idMeta :: a,
    _idSort :: IdSort
  }
  deriving stock (Show, Eq, Ord, Functor, Foldable, Traversable, Generic, Data, Typeable)

instance Eq1 Id where
  liftEq eq id1 id2 = id1._idName == id2._idName && id1._idUniq == id2._idUniq && eq (id1._idMeta) (id2._idMeta) && id1._idSort == id2._idSort

instance Ord1 Id where
  liftCompare cmp id1 id2 = compare (id1._idName) (id2._idName) <> compare (id1._idUniq) (id2._idUniq) <> cmp (id1._idMeta) (id2._idMeta) <> compare (id1._idSort) (id2._idSort)

instance Show1 Id where
  liftShowsPrec showPrec _ d Id {..} = showString "Id " . showsPrec d _idName . showString " " . showsPrec d _idUniq . showString " " . showPrec d _idMeta . showString " " . showsPrec d _idSort

-- TODO: calculate hash from idUniq
instance Eq a => Hashable (Id a) where
  hashWithSalt salt Id {_idUniq} = hashWithSalt salt _idUniq

instance Binary a => Binary (Id a)

instance ToJSON a => ToJSON (Id a)

instance ToJSON a => ToJSONKey (Id a)

instance FromJSON a => FromJSON (Id a)

instance FromJSON a => FromJSONKey (Id a)

noName :: Text
noName = "noName"

idToText :: Id a -> Text
idToText Id {_idName, _idSort = External (ModuleName modName)} = modName <> "." <> _idName
idToText Id {_idName, _idUniq, _idSort = Internal} = _idName <> "_" <> toText (showHex _idUniq "")
idToText Id {_idName, _idUniq, _idSort = Temporal} = "$" <> _idName <> "_" <> toText (showHex _idUniq "")
idToText Id {_idName, _idUniq, _idSort = Native} = _idName

pPrintMeta :: (t -> Doc) -> t -> Doc

#ifdef DEBUG
pPrintMeta ppr x = braces (ppr x)
#else
pPrintMeta _ _ = mempty
#endif

instance Pretty a => Pretty (Id a) where
  pPrint id@(Id _ _ m _) = pprIdName id <> pPrintMeta pPrint m
    where
      pprIdName :: Id a -> Doc
      pprIdName = text . toString . idToText

idName :: Lens' (Id a) Text
idName = lens (._idName) (\i x -> i {_idName = x})

idUniq :: Lens' (Id a) Int
idUniq = lens (._idUniq) (\i x -> i {_idUniq = x})

idMeta :: Lens (Id a) (Id b) a b
idMeta = lens (._idMeta) (\i x -> i {_idMeta = x})

idSort :: Lens' (Id a) IdSort
idSort = lens (._idSort) (\i x -> i {_idSort = x})

newNoNameId :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => a -> IdSort -> f (Id a)
newNoNameId m s = Id noName <$> getUniq <*> pure m <*> pure s

newTemporalId :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => Text -> a -> f (Id a)
newTemporalId n m = Id n <$> getUniq <*> pure m <*> pure Temporal

newInternalId :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => Text -> a -> f (Id a)
newInternalId n m = Id n <$> getUniq <*> pure m <*> pure Internal

newExternalId :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => Text -> a -> ModuleName -> f (Id a)
newExternalId n m modName = Id n <$> getUniq <*> pure m <*> pure (External modName)

newNativeId :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => Text -> a -> f (Id a)
newNativeId n m = Id n <$> getUniq <*> pure m <*> pure Native

newIdOnName :: (MonadIO f, HasUniqSupply env UniqSupply, MonadReader env f) => a -> Id b -> f (Id a)
newIdOnName meta Id {_idName, _idSort} = Id _idName <$> getUniq <*> pure meta <*> pure _idSort

cloneId :: (MonadIO m, HasUniqSupply env UniqSupply, MonadReader env m) => Id a -> m (Id a)
cloneId Id {..} = do
  _idUniq <- getUniq
  pure Id {_idName, _idUniq, _idMeta, _idSort}

idIsExternal :: Id a -> Bool
idIsExternal Id {_idSort = External _} = True
idIsExternal _ = False

idIsNative :: Id a -> Bool
idIsNative Id {_idSort = Native} = True
idIsNative _ = False
