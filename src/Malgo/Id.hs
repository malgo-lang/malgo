{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

module Malgo.Id
  ( IdSort (..),
    Id (..),
    Meta (..),
    idToText,
    newInternalId,
    newExternalId,
    idIsExternal,
    newTemporalId,
    withMeta,
  )
where

import Data.Aeson (FromJSON, ToJSON)
import Data.Data (Data)
import Data.SCargot.Repr.Basic qualified as S
import Data.Store ()
import Data.Store.TH
import Effectful (Eff, (:>))
import Effectful.Reader.Static (Reader, ask)
import Effectful.State.Static.Local (State)
import Malgo.Module
import Malgo.Prelude hiding (toList)
import Malgo.SExpr qualified as S
import Prettyprinter (brackets, (<+>))

-- | Identifier sort.
data IdSort
  = -- | Identifiers that can be referenced by other `External` modules.
    -- They are printed as `ModuleName.idName`.
    External
  | -- | Identifiers closed in the module. They are not visible outside (so `Internal`) the module.
    -- They are printed as `idName_deadbeaf`.
    Internal Int
  | -- | Temporary variable identifiers generated by the compiler.
    -- For dev experience, these are printed with a prefix `$`.
    Temporal Int
  deriving stock (Eq, Show, Ord, Generic, Data)
  deriving anyclass (Hashable, ToJSON, FromJSON)
  deriving (Pretty) via PrettyShow IdSort

makeStore ''IdSort

data Id = Id
  { name :: Text,
    moduleName :: ModuleName,
    sort :: IdSort
  }
  deriving stock (Show, Eq, Ord, Generic, Data)
  deriving anyclass (Hashable, ToJSON, FromJSON)

instance Pretty Id where
  pretty Id {name, sort = External} = pretty name
  pretty Id {name, moduleName, sort = Internal uniq} = "#" <> brackets (pretty moduleName <+> pretty name <+> pretty uniq)
  pretty Id {name, moduleName, sort = Temporal uniq} = "$" <> brackets (pretty moduleName <+> pretty name <+> pretty uniq)

instance S.ToSExpr Id where
  toSExpr Id {name, sort = External} = S.A $ S.Symbol name
  toSExpr Id {name, moduleName, sort = Internal _uniq} = S.A $ S.Symbol $ "#" <> moduleNameDigest moduleName <> "." <> name <> "_" <> "xxx"
  toSExpr Id {name, moduleName, sort = Temporal _uniq} = S.A $ S.Symbol $ "$" <> moduleNameDigest moduleName <> "." <> name <> "_" <> "xxx"

makeStore ''Id

data Meta a = Meta
  { meta :: a,
    id :: Id
  }
  deriving stock (Show, Eq, Ord, Functor, Foldable, Traversable, Generic, Data)
  deriving anyclass (Hashable, ToJSON, FromJSON)

withMeta :: a -> Id -> Meta a
withMeta meta id = Meta {..}

instance Pretty (Meta a) where
  pretty Meta {id} = pretty id

instance S.ToSExpr (Meta a) where
  toSExpr Meta {id} = S.toSExpr id

makeStore ''Meta

idToText :: Id -> Text
idToText Id {name, moduleName, sort = External} = moduleNameToString moduleName <> "." <> name
idToText Id {name, moduleName, sort = Internal uniq} = moduleNameToString moduleName <> ".#" <> name <> "_" <> convertString (show uniq)
idToText Id {name, moduleName, sort = Temporal uniq} = moduleNameToString moduleName <> ".$" <> name <> "_" <> convertString (show uniq)

newTemporalId :: (State Uniq :> es, Reader ModuleName :> es) => Text -> Eff es Id
newTemporalId name = do
  uniq <- getUniq
  moduleName <- ask @ModuleName
  let sort = Temporal uniq
  pure Id {..}

newInternalId :: (State Uniq :> es, Reader ModuleName :> es) => Text -> Eff es Id
newInternalId name = do
  uniq <- getUniq
  moduleName <- ask @ModuleName
  let sort = Internal uniq
  pure Id {..}

newExternalId :: (Reader ModuleName :> es) => Text -> Eff es Id
newExternalId name = do
  moduleName <- ask @ModuleName
  let sort = External
  pure Id {..}

idIsExternal :: Id -> Bool
idIsExternal Id {sort = External} = True
idIsExternal _ = False
