{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TemplateHaskell #-}

module Malgo.Id
  ( IdSort (..),
    Id (..),
    Meta (..),
    idToText,
    newInternalId,
    newExternalId,
    idIsExternal,
    newTemporalId,
    newNativeId,
    idIsNative,
    withMeta,
  )
where

import Data.Aeson (FromJSON, ToJSON)
import Data.Data (Data)
import Data.Store ()
import Data.Store.TH
import Effectful (Eff, (:>))
import Effectful.Reader.Static (Reader, ask)
import Effectful.State.Static.Local (State)
import Malgo.Module
import Malgo.MonadUniq
import Malgo.Prelude hiding (toList)

-- | Identifier sort.
data IdSort
  = -- | Identifiers that can be referenced by other `External` modules.
    -- They are printed as `ModuleName.idName`.
    External
  | -- | Identifiers closed in the module. They are not visible outside (so `Internal`) the module.
    -- They are printed as `idName_deadbeaf`.
    Internal Int
  | -- | Temporary variable identifiers generated by the compiler.
    -- For dev experience, these are printed with a prefix `$`.
    Temporal Int
  | -- | Native identifiers, e.g. `main` that is the entry point function name.
    --   These are only generated by the compiler.
    --   These are `Native`, so they are printed raw. No prefix and no postfix.
    Native
  deriving stock (Eq, Show, Ord, Generic, Data, Typeable)
  deriving anyclass (Hashable, ToJSON, FromJSON)
  deriving (Pretty) via PrettyShow IdSort

makeStore ''IdSort

data Id = Id
  { name :: Text,
    moduleName :: ModuleName,
    sort :: IdSort
  }
  deriving stock (Show, Eq, Ord, Generic, Data, Typeable)
  deriving anyclass (Hashable, ToJSON, FromJSON)

instance Pretty Id where
  pretty Id {name, sort = External} = pretty name
  pretty Id {name, moduleName, sort = Internal uniq} = "#" <> brackets (pretty moduleName <+> pretty name <+> pretty uniq)
  pretty Id {name, moduleName, sort = Temporal uniq} = "$" <> brackets (pretty moduleName <+> pretty name <+> pretty uniq)
  pretty Id {name, sort = Native} = "%" <> pretty name

makeStore ''Id

data Meta a = Meta
  { meta :: a,
    id :: Id
  }
  deriving stock (Show, Eq, Ord, Functor, Foldable, Traversable, Generic, Data, Typeable)
  deriving anyclass (Hashable, ToJSON, FromJSON)

withMeta :: a -> Id -> Meta a
withMeta meta id = Meta {..}

instance (Pretty a) => Pretty (Meta a) where
  pretty Meta {id} = pretty id

makeStore ''Meta

idToText :: Id -> Text
idToText Id {name, moduleName, sort = External} = moduleNameToString moduleName <> "." <> name
idToText Id {name, moduleName, sort = Internal uniq} = moduleNameToString moduleName <> ".#" <> name <> "_" <> convertString (show uniq)
idToText Id {name, moduleName, sort = Temporal uniq} = moduleNameToString moduleName <> ".$" <> name <> "_" <> convertString (show uniq)
idToText Id {name, sort = Native} = name

newTemporalId :: (State Uniq :> es, Reader ModuleName :> es) => Text -> Eff es Id
newTemporalId name = do
  uniq <- getUniq
  moduleName <- ask @ModuleName
  let sort = Temporal uniq
  pure Id {..}

newInternalId :: (State Uniq :> es, Reader ModuleName :> es) => Text -> Eff es Id
newInternalId name = do
  uniq <- getUniq
  moduleName <- ask @ModuleName
  let sort = Internal uniq
  pure Id {..}

newExternalId :: (Reader ModuleName :> es) => Text -> Eff es Id
newExternalId name = do
  moduleName <- ask @ModuleName
  let sort = External
  pure Id {..}

newNativeId :: (Reader ModuleName :> es) => Text -> Eff es Id
newNativeId name = do
  moduleName <- ask @ModuleName
  let sort = Native
  pure Id {..}

idIsExternal :: Id -> Bool
idIsExternal Id {sort = External} = True
idIsExternal _ = False

idIsNative :: Id -> Bool
idIsNative Id {sort = Native} = True
idIsNative _ = False