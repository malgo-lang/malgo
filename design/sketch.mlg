-- コメント

-- トップレベル再帰関数
fib n =
  if n == 0 then 1
  else fib (n - 1) + fib (n - 2)

-- 高階関数
twice f x = f (f x)

-- ヴァリアント型
-- ヴァリアント型は宣言しないと使えない
type List a = nil {} 
            | cons { car : a, cdr : List a}

head : List a -> a
head lst =
  case lst of
    | nil _ => error "nil" -- error str = eprintln str; exit 1
    | cons { car = x, cdr = _ } => x

sum : List Int -> Int;
sum lst =
  case lst of
    -- 型推論でasは省略可能
    -- nilとconsを持ち、要素の型が一致するヴァリアント型が一意に定まるならそれ、定まらなければ型エラー
    | nil _ => 0
    | cons { car = x, cdr = xs } => x + sum xs;

sumAcc lst =
  let go lst acc =
    case lst of
      -- こういうパターンではList Intを推論する
      -- もし他のモジュールにnilとconsを持つ型があれば型エラー。名前解決エラーかも
      | nil _ => acc
      | cons { car = x, cdr = xs } => go xs (x + acc)
  in go lst 0;

evenOdd x =
  -- 関数内で再帰関数を定義できる。各宣言をandでつなぐ
  let even x =
    -- if は if then else
    if x == 0 then true
    else odd (x - 1)
  and odd x =
    if x == 0 then false
    else even (x - 1)
  in { e = even x, o = odd x}

type Option a = none {}
              | some a

noneC : Option a
noneC = none {}

someC : a -> Option a
someC a = some a

safeHead : List a -> Option a
safeHead = \lst ->
  case lst of
    | nil _ => none {}
    | cons { car = x, cdr = _ } => some x

-- 型クラス
class Eq a = {
  eq : a -> a -> Bool
}

instance Eq Int = {
  eq = \x -> \y -> eqInt x y
}

zeroIsOne = eq 1 2

-- 多段階計算
aux : Int -> Int -> 'Int
aux n s =
  if n <= 0
  then '1
  else '(~s * ~(aux (n - 1) s))

genpower : Int -> '(Int -> Int)
genpower n = '(\x -> ~(aux n 'x))

power2 = ~genpower 2

-- 型クラスインスタンス定義の自動生成
-- 多段階計算でこういうことをするには宣言が第一級じゃないとだめそう…
-- [Type a]とかを使えるようにするには[forall a. Type a]と推論する必要があり、かなり大変
implEq : Type a -> (a -> a -> Bool) -> 'Decl
implEq type equality = '(instance Eq ~type = { eq = ~equality })

-- 単純にマクロにする？マクロの設計は難しい…
macro genpower n = [expr| \x -> ~(aux n 'x)]
